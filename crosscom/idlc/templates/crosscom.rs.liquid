use std::{ffi::c_void, os::raw::c_long};

use crosscom::ComInterface;
use uuid::Uuid;


{% for iface in model.interfaces %}

/////////////////////// Interface {{ iface.name }} ///////////////////////

#[repr(C)]
#[allow(non_snake_case)]
pub struct {{ iface.name }}VirtualTable {
    {% for method in iface.all_methods %}
    pub {{ method.name }}: {{ method.raw_signature }},
    {% endfor %}
}

#[allow(dead_code)]
#[repr(C)]
pub struct {{ iface.name }}VirtualTableCcw {
    pub offset: isize,
    pub vtable: {{ iface.name }}VirtualTable,
}

#[allow(dead_code)]
#[repr(C)]
pub struct {{ iface.name }} {
    pub vtable: *const {{ iface.name }}VirtualTable,
}

#[allow(dead_code)]
#[allow(non_snake_case)]
#[allow(unused)]
impl {{ iface.name }} {
    // {{ iface.uuid }}
    pub const INTERFACE_ID: [u8; 16] = [
        {{ iface.uuid | uuid_hex_array }}
    ];
    
    {% for method in iface.all_methods %}
        pub {{ method.signature_with_name }} {
            unsafe {
                let this = self as *const {{ iface.name }} as *const c_void;
                ((*self.vtable).{{ method.name }})(this, {{ method.argument_list }})
            }
        }
    {% endfor %}
}


pub trait {{ iface.name }}Trait {
    {% for method in iface.methods %}
    {{ method.signature_with_name }};
    {% endfor %}
}

impl ComInterface for {{ iface.name }} {}

{% endfor %}

{% for class in model.classes %}
/////////////////////// Class {{ class.name }} ///////////////////////

#[allow(unused)]
macro_rules! implement_Test {
    ($impl_type: ty) => {

#[allow(dead_code)]
#[allow(non_snake_case)]
#[allow(unused)]
mod {{class.name}}_impl {

{% for iface in model.interfaces %}
use {{ ns_prefix }}::{{ iface.name }}Trait;
{% endfor %}

#[repr(C)]
pub struct {{ class.name }}Ccw {
    {% for parent in class.parents %}
    {{ parent.name }}: {{ ns_prefix }}::{{ parent.name }},
    {% endfor %}

    ref_count: std::sync::atomic::AtomicU32,
    inner: $impl_type,
}

unsafe extern "system" fn query_interface(
    this: *const std::os::raw::c_void,
    guid: uuid::Uuid,
    retval: *mut std::os::raw::c_void,
) -> std::os::raw::c_long {
    let object = crosscom::get_object::<{{ class.name }}Ccw>(this);

{% for parent in class.parents %}
    0
{% endfor %}
}

unsafe extern "system" fn add_ref(this: *const std::os::raw::c_void) -> std::os::raw::c_long {
    let object = crosscom::get_object::<{{ class.name }}Ccw>(this);
    let previous = (*object).ref_count.fetch_add(1, std::sync::atomic::Ordering::SeqCst);
    (previous + 1) as std::os::raw::c_long
}

unsafe extern "system" fn release(this: *const std::os::raw::c_void) -> std::os::raw::c_long {
    let object = crosscom::get_object::<{{ class.name }}Ccw>(this);

    let previous = (*object).ref_count.fetch_sub(1, std::sync::atomic::Ordering::SeqCst);
    if previous - 1 == 0 {
        Box::from_raw(object as *mut {{ class.name }}Ccw);
    }

    (previous - 1) as std::os::raw::c_long
}

{% for method in class.methods_to_implement %}
{{method.raw_signature_with_name}} {
    let object = crosscom::get_object::<{{ class.name }}Ccw>(this);
    (*object).inner.{{ method.name }}();
}
{% endfor %}

{% for parent in class.parents %}
#[allow(non_upper_case_globals)]
pub const GLOBAL_{{ parent.name }}VirtualTable_CCW_FOR_{{ class.name }}: {{ ns_prefix }}::{{ parent.name }}VirtualTableCcw 
    = {{ ns_prefix }}::{{ parent.name }}VirtualTableCcw {
    offset: {{ parent.offset }},
    vtable: {{ ns_prefix }}::{{ parent.name }}VirtualTable {
        {% for method in parent.all_methods %}
        {{ method.name }},
        {% endfor %}
    },
};
{% endfor %}

impl {{ class.name }}Ccw {
    pub fn new(inner: $impl_type) -> {{ class.name }}Ccw {
        Self {
            {% for parent in class.parents %}
            {{ parent.name }}: {{ ns_prefix }}::{{ parent.name }} {
                vtable: &GLOBAL_{{ parent.name }}VirtualTable_CCW_FOR_{{class.name}}.vtable
                    as *const {{ ns_prefix }}::{{ parent.name }}VirtualTable,
            },
            {% endfor %}
            ref_count: std::sync::atomic::AtomicU32::new(1),
            inner,
        }
    }
}

impl crosscom::ComObject for $impl_type {
    type CcwType = {{ class.name }}Ccw;

    fn create_ccw(self) -> Self::CcwType {
        Self::CcwType::new(self)
    }
}


}
};
}

{% endfor %}
